//
//  file.cpp
//  nadocoding
//
//  Created by 안동규 on 2021/07/19.
//

// #define _CRT_SECURE_NO_WARNINGS  // 적당한 오류 무시하는 문구 같음. 나중에 찾아보기

#include <stdio.h>
#define MAX 10000
// 이렇게 사용하면 MAX가 상수가 되고,
// MAX는 10000으로 치환이 된다.
// define A B => B를 A로 치환해서 사용할게요!
// 구조체에서 typedef는,
// typedef struct (구조체명) {} 별명;

int main_flie(void)
{
    // 파일 입출력에 관해서
    // 파일에 어떤 데이터를 저장했는지,
    // 파일에 저장된 데이터를 불러오기
    // fputs, fgets  // 각각 짝을 이루는 함수들(보통 문자열을 저장하고 읽어오기 위해서)
    // fprintf, fscanf  // 두 쌍을 서로 섞어도 큰 상관은 없음
    // fprintf와 fscanf는 printf와 scanf처럼 정형화된 서식문자를 이용해서
    // 거기에 맞춰서 입력을 하고 싶을때 쓴다.
    // printf("%d %d %s...")
    // scanf(" %d %d %num1...") 처럼 정형화된 형식에 맞게 입력하고 싶을때 사용
    // 함께 예전에 공부했었던 scanf와 scanf_s, gets와 fgets의 차이도 복습하면 좋을 듯!

    char line[MAX];  // define했던 것을 가지고 아주 큰 문자열을 만들어준다.
    
    // fopen에 대해서 알아보자!
    // 파일에 쓰기!
//    FILE *file = fopen("/Users/andong-gyu/Documents/coding practice 2/nadocoding/test1.txt", "wb");
//    // FILE *file = fopen("파일경로","불러올 형태");
//    // 이 문구는 파일을 열겠다는 의미인데 관련해서는 따로 공부를 해야 할 거 같다. 노션 참고!
//    // ("c:\\test1.txt", "wb");
//    // c드라이브에 test1 파일을 생성하고 wb형식으로 열거에요!, 하는 문구인데
//    // 탐색기에서는 역슬레쉬를 하나만 적어주어도 되지만
//    // 소스코드에서는 역슬레쉬를 두 개를 적어야 하나로 인식을 한다.
//    // 탈출문자로 인식되지 않기 위함임! 아마 열혈 앞부분에서 본 것 같음. 이스케이프 시퀀스 관련!
//    // 여는 방식은 r : 읽기 전용, w : 쓰기 전용, a : 이어쓰기
//    // 뒤에 오는 문자는 2가지가 있는데 t: text, b : binary data
//    if (file == NULL)  // 만약에 파일이 없으면
//    {
//        printf("파일 열기 실패!\n");
//        return 1;
//    }
//
//    fputs("fputs를 이용해서 글을 적어볼게요\n", file);
//    // 앞에는 작성할 내용 혹은 내용이 들어갈 주소를 적고, 뒤에는 아까 명시해둔 포인터를 적어주면 된다.
//    // fputs("이 내용을", 이 포인터 주소에 저장할게요~);
//    fputs("잘 적히는지 확인해주세요\n", file);
//
//    fclose(file);
    // 이렇게 하면 파일을 저장하고 닫아준다.
    // 만약 파일을 열고 나서 닫지 않은 상태에서 어떤 프로그램에서 문제가 생긴다면?
    // 데이터 손실이 발생할 수 있기 때문에 항상 파일은 닫아주는 습관을 들이자!!! ==== 매우 중요!
    // fclose(file); 해주는 습관을 들이자!
    
    // 작동이 안되어서 한참을 고민해 보니까,
    // 아마도 맥북에서는 c드라이브가 없어서 그런거 같다!
    // 역시 fopen("documents//coding\\practice\\2//nadocoding//test1.txt", "wb");
    // 이렇게 입력하니까 되긴 빌드가 작동되긴 한다.
    // 추가적으로 알게 된 것은 정방향 슬레쉬(/)는 폴더 간의 이동,
    // 역 슬레쉬(\)는 파일명 사이의 띄워쓰기를 나타내는 거 같다.
    
    // ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
    // 아! 찾았다! 그냥 파인더에서 파일을 만들 폴더로 가서,
    // 상단메뉴바에 있는 '파일'을 클릭, '정보 가져오기'클릭해서 (단축키는 커맨드 + I 이다.)
    // 거기 있는 위치를 그냥 드래그 해서 복사-붙여넣기를 하면 된다!
    // /Users/andong-gyu/Documents/coding practice 2
    // 그리고 그냥 띄워쓰기 다 됨. 역슬레쉬 정방향 슬레쉬 필요없고 정방향 슬레쉬만
    // 폴더 간 이동에서 사용하면 됨.
    
    
    
    // 이번에는 fgets에 대해서 알아보겠습니다!
    // 즉, 쓴 파일에 대해서 읽어보는 것이다.
//    FILE *file = fopen("/Users/andong-gyu/Documents/coding practice 2/nadocoding/test1.txt", "rb");
//
//    if (file == NULL)
//    {
//        printf("파일 열기 실패!\n");
//        return 1;
//    }
//
//    // fgets는 한 줄 단위로 해서 불러오겠음!
//    while(fgets(line, MAX, file) != NULL)
//    {
//        printf("%s", line);
//    }
//    // 파일을 불러오면 이 값을 저장해두어야 되는데
//    // 그 저장을 위에서 정의해둔 line[MAX]에다가 해보도록 합시다!
//    // 파라미터 순서는 fgets(저장될 곳, 사이즈, 파일포인터_문자열이 저장된 주소)를 적으면 된다.
//    // != NULL , 빈 칸이 아니면 출력해주세요~
//
//    fclose(file);
    
    // 어? 처음 하니까 안되네? 왜 안되는지 살펴보니까
    // FILE *file = fopen("/Users/andong-gyu/Documents/coding practice 2/nadocoding/test1.txt", "wb");
    // 여기서 wb라고 되어 있어서 그렇다. 위에 설명을 읽으면 알겠지만 wb에서 w는 쓰기이다.
    // 그래서 이것을 읽기로 고쳐야 함! rb로 수정해주자.
    
    // 이렇게 하니까 파일 내용이 다 지워져서 읽어오질 못하네? 흠...
    // 파일쓰는 시퀀스를 한 번 더 진행을 시켜서 파일을 다시 만들어보자.
    // 아하, 처음 실행을 시킬때 wb로 실행을 시켰더니, 적은게 없어서 빈 txt파일이 되어버림.
    // 이어서 쓰기 위해서는 ab를 해야함!
    // 그래서 fputs 시퀀스를 wb로 다시 진행시킨 다음에
    // 바로 rb로 fgets를 진행시켜주자!
    
    // 이제 된다!!!!!!!!!!!!!!!!!!
    
    
    
    // 이제 fprint와 fscanf를 배워보자.
    // 위에 설명해둔 것 처럼 정형화된 서식문자에 대해서 쓰고 읽어 오기 위해서
    // 자주 쓴다. 물론 문자열에서도 써먹을 수도 있다.
    // 작은 예제를 만들어보자. 로또 번호를 저장하고 가져오는 간단한 프로그램을 만들어보자.
//    printf("이번주 로또 당첨 번호!\n");
    
    
    
    

    int num[6] = {0,0,0,0,0,0};  // 추첨번호
    int bonus = 0;  // 보너스번호
    char str1[MAX];  // 파일을 읽어와서 출력하기 위해서 설정
    char str2[MAX];
    // 문자열 배열이다! 여기서 str1과 str2는 뭐다?
    // 맞다, 문자열이 저장될 주소와도 같다. 문자열에서는 그렇다.
    // 음... 원래 문자열은 선언과 동시에 초기화를 해주어야 하는데..
    // 그냥, MAX크기를 가진 str1주소라고 생각하자.
    
//    FILE *file = fopen("/Users/andong-gyu/Documents/coding practice 2/text2.txt","wb");
//    // 이 로또번호는 text2번 파일에 적을거임. 그 파일은 wb, 즉 쓰기 전용으로 불러오겠다.
//    if(file == NULL)
//    {
//        printf("파일 열기 실패!\n");
//        return 1;
//        // 쉽게 말해서 return 0은 정상종료. 기타 리턴 값은 비정상적인 종료 시에!
//        // 원래 1은 참, 0은 거짓인데 그거랑은 별개로 생각하면 될 듯.
//    }
//
//    // 이제는 로또 추첨 번호를 저장해야 함!\
//    // 파라미터 순서는, 포인터 이름 먼저 적고,
//    // 그 다음에 ""를 이용해서 출력 값을 정해준다.
//    fprintf(file, "%s %d %d %d %d %d %d\n", "추첨번호", 1,2,3,4,5,6);
//    fprintf(file, "%s %d\n", "보너스번호", 7);
//    fclose(file);
    // flcose에서는 포인터명 꼭 입력해주기~

    // 정상적으로 입력이 되었습니다~

    // 이번에는 파일을 읽어와보도록 하자
    // 파일에 읽기 부분을 작성해보자
    FILE *file = fopen("/Users/andong-gyu/Documents/coding practice 2/text2.txt","rb");

    if(file == NULL)
    {
        printf("파일 열기 실패!\n");
        return 1;
    }

    // 마찬가지로 문장을 불러오면
    // 저장을 해야하는데, 첫번째 문장은 str1에 저장하고
    // 두번째 문장은 str2에 저장하겠음
    fscanf(file, "%s %d %d %d %d %d %d", str1,
           &num[0], &num[1], &num[2], &num[3], &num[4], &num[5]);
    // 이렇게 str1과 배열을 통해서 읽어 온 것을
    // printf를 통해서 출력을 한다.
    printf("%s %d %d %d %d %d %d\n\n", str1,
           num[0], num[1], num[2], num[3], num[4], num[5]);

    fscanf(file, "%s %d\n", str2, &bonus);
    printf("%s %d\n", str2, bonus);
    // 포인터형은 &붙일 필요가 없다.
    // str1은 문자열이기 때문에 char *file과 같음! = ?
    // 원래 str1이 배열이면 str + i 하면, file과 같은것 아닌가...
    // 설명은 캐릭터 배열이면 앞에 & 안붙여도 된다.
    // 캐릭터 배열은 캐릭터 포인터랑 같다고 함. 무슨 소뤼쥥... = 밑에 정리완료
    // 그리고 fscanf에서는 그냥, 포인터file에 저장된 문자열 주소를 str1으로 불러온다고 생각하자.

    
    
    
    // 막간 공부, 코딩도장 : 39.2 문자열 포인터에서 인덱스로 문자에 접근하기
    
//    char *s1 = "HELLO";  // 포인터에 문자열 HELLO의 주소를 저장
//    printf("%c\n", s1[1]);  // e출력
//    printf("%c\n", s1[4]);  // o출력
//    printf("%c\n", s1[5]);  // NULL을 출력
//    // 오홍? 된다~ 문자열 포인터는 인덱스로 접근이 가능하구나!
//    // 읽어오는 것도 되는데, 문자를 할당할 수도 있는거 아닐까?
//
//    s1[0] = 'A';  // 문자열 포인터(문자열 배열)의 첫 번째 칸을 A로 바꿔주려고 시도!
//    printf("%c\n", s1[0]);
//    // 에러발생! 문자열 리터럴이 있는 메모리 주소는 읽기 전용이기 때문에,
//    // 문자열 포인터는 인덱스로 접근하여 문자열을 할당해서는 안된다.
    
//    char s1[10];  // 크기가 10인 char형 배열을 선언
//    s1 = "Hello";  // 에러발생!
//    // 배열에 문자열을 지정하려면 에러가 발생한다. 즉, 선언과 동시에 초기화를 진행해주어야 한다.
//    // 정 하고 싶으면,
//    s1[0]='H';
//    s1[1]='e';
//    s1[2]='l';
//    s1[3]='l';
//    s1[4]='o';
//    // 이렇게 하나씩 지정해주어야 한다. 포인터에서는 읽기 전용이라서
//    // 문자를 할당하는 것은 안되지만, 배열은 가능하다.
    
//    // 대신 배열명은 주소값 변경이 안된다.
//    // 포인터는 그 주소값에 다른 값을 할당할 수 있지만, 배열은 안된다.
//    // 자세한 내용은 열혈 C프로그래밍 참조
    
//    char s1[10] = "Hello";
//    printf("%s\n", s1);
//    // 10칸을 만들어주고 글자 5개만?
//    // 괜찮다. 나머지는 NULL값이 들어간다.
//    // 참고로 문자열 포인터에서는 그 포인터가
//    // 문자열이 저장된 주소 그 자체를 나타낸다고 하는데,
//    // 마찬가지로 문자열 배열인 s1은
//    // s1자체가 주소값을 나타내기도 하니 이렇게 해주어도 된다.
//
//    char c1[3] = "Hello";
//    printf("%s\n", c1);
//    // 하지만 배열 길이를 [3]으로 해놓고 5글자를 집어넣으면 제대로 출력이 안된다.
//    // 저 hello를 입력하기 위해서는 어느 정도의 길이가 딱인가?
//    // 5? 아니다 NULL값을 포함해야 하기 때문에 6이다.
//    // 일반적인 배열과 같이 길이를 비워놓고 문자를 입력해주어도 된다.
//
//    // 배열이기 때문에 포인터일때와는 다르게 인덱스로 접근하여 문자를 할당할 수도 있다.
//    s1[0] = 'A';
//    printf("%s\n",s1);
//    // 된다! 머선일이고... 문자열이 지정되어있는 주소임에도
//    // 새로운 문자가 할당이 된다.
//    // 문자열 포인터도 있고 배열도 알아보았는데,
//    // 가장 중요한 것은 문자열은 포인터로도, 배열로도 사용할 수 있다는
//    // 그 자체이다.
    
    // 막간 공부 끝
    
    
    
    
    return 0;
}
