//
//  pointer.cpp
//  nadocoding
//
//  Created by 안동규 on 2021/06/09.
//

#include <stdio.h>

// 선언
void swap(int a, int b);
void swap_addr(int *a,int *b);
void changearray(int *ptr);

int main_pointer(void)
{
    // 포인터
    
    // [철수] : 101호 _메모리 공간의 주소
    // [영희] : 201호
    // [민수] : 301호
    // 각 문엔 '암호'가 설정되어 있음
//    int 철수 = 1;  // 암호
//    int 영희 = 2;
//    int 민수 = 3;
//
//    printf("철수네 주소 : %d, 암호 : %d\n", &철수, 철수);
//    // '&철수'로 적으면 메모리 공간 상의 주소를 알 수 있게 된다.
//    printf("영희네 주소 : %d, 암호 : %d\n", &영희, 영희);
//    printf("민수네 주소 : %d, 암호 : %d\n", &민수, 민수);
//
//    // 미션맨의 등장!(포인터)
//
//    // *sth은 포인터 변수를 정의하는 방법임. 포인터는 주소를 가질 수 있다.
//    // *sth을 이용해 해당 주소의 값을 가지고 오는 것을 '역참조'라고 한다.
//    // int *sth; 에서 sth은 int 포인터형이고, *sth은 int형이다.
//    // *sth = y 처럼 역참조를 이용해서 sth 주소에 있는 값을 y로 바꿀 수 있다.
//
//    // 첫번째 미션 : 아파트의 각 집에 방문하여 문에 적힌 암호 확인
//    int *미션맨;  // 이게 바로 포인터 변수. 앞에 '*'별이 붙음
//    미션맨 = &철수;  // 미션맨은 철수의 주소값을 가지도록 선언을 함.
//    printf("미션맨이 방문하는 곳 주소 : %d, 암호 : %d\n", 미션맨, *미션맨);
//    // 미션맨이라는 값 자체는 철수의 주소지만 그 곳의 값을 가져오기 위해서는 *을 붙여주어야 함.
//    미션맨 = &영희;
//    printf("미션맨이 방문하는 곳 주소 : %d, 암호 : %d\n", 미션맨, *미션맨);
//    미션맨 = &민수;
//    printf("미션맨이 방문하는 곳 주소 : %d, 암호 : %d\n", 미션맨, *미션맨);
//
//    // 두 번째 미션 : 각 암호에 3을 곱해라.
//    // 이것으로 알 수 있는 곳은 포인터는 해당 주소에 가서 저장된 값도 가져올 수 있고
//    // 그 값을 수정할 수도 있다!
//    미션맨 = &철수;
//    *미션맨 *= 3;
//    printf("미션맨이 암호를 바꾼 곳 주소 : %d, 암호 : %d\n", 미션맨, *미션맨);
//
//    미션맨 = &영희;
//    *미션맨 *= 3;
//    printf("미션맨이 암호를 바꾼 곳 주소 : %d, 암호 : %d\n", 미션맨, *미션맨);
//
//    미션맨 = &민수;
//    *미션맨 *= 3;
//    printf("미션맨이 암호를 바꾼 곳 주소 : %d, 암호 : %d\n", 미션맨, *미션맨);
//
//    // 스파이
//    // 미션맨이 바꾼 암호에 2를 빼라!
//    int *스파이 = 미션맨;
//    printf("\n...스파이가 미션을 수행하는 중!...\n");
//    스파이 = &철수;
//    *스파이 -= 2;  // 철수 = 철수 - 2; 와 같은 문장이다.
//    printf("스파이가 방문하는 곳 주소: %d, 암호: %d\n", 스파이, *스파이);
//
//    스파이 = &영희;
//    *스파이 -= 2;  // 철수 = 철수 - 2; 와 같은 문장이다.
//    printf("스파이가 방문하는 곳 주소: %d, 암호: %d\n", 스파이, *스파이);
//
//    스파이 = &민수;
//    *스파이 -= 2;  // 철수 = 철수 - 2; 와 같은 문장이다.
//    printf("스파이가 방문하는 곳 주소: %d, 암호: %d\n", 스파이, *스파이);
//
//    // 이렇게 하면 정말로 주소에 있는 값이 바뀌는지 확인을 해보자!
//    printf("철수네 주소 : %d, 암호 : %d\n", &철수, 철수);
//    printf("영희네 주소 : %d, 암호 : %d\n", &영희, 영희);
//    printf("민수네 주소 : %d, 암호 : %d\n", &민수, 민수);
//    // 결과적으로, 포인터 변수라는 것은 어떤 변수의 주소값을 가지는 포인터 자체가
//    // 그 변수의 값을 바꿀 수 있다는 것을 확인할 수 있다.
//
//    // 참고로, 미션맨이 사는 곳의 주소도 &미션맨으로 확인 가능
//    // 포인터 변수도 하나의 변수라서 메모리 상에서 주소 값을 가진다.
//    printf("미션맨의 주소: %d\n", &미션맨);
//    printf("스파이의 주소: %d\n", &스파이);
    
    // 배열과 포인터의 관계
//    int arr[3] = {5,10,15};
//    int *ptr = arr;
//    for (int i=0; i<3; i++)
//    {
//        printf("배열 arr[%d] 의 값: %d\n", i, arr[i]);
//    }
//    for (int i=0; i<3; i++)
//    {
//        printf("포인터 ptr[%d] 의 값: %d\n", i, ptr[i]);
//    }
//    // 같은 값을 도출해낸다. arr과 ptr은 똑같은 것으로 볼 수 있음.
//    // 포인터 변수를 배열로 초기화 해놓으면 배열의 이름이 곧 포인터가 된다.
//
//    ptr[0]=100;
//    ptr[1]=200;
//    ptr[2]=300;
//    for (int i=0; i<3; i++)
//    {
//        printf("배열 arr[%d] 의 값: %d\n", i, arr[i]);
//        printf("배열 arr[%d] 의 값: %d\n", i, *(arr+i));  // 위와 똑같은 표현이다.
//        // arr은 배열이 시작하는 첫번째 주소값을 나타내는데
//        // 그로부터 +i주소만큼의 값을 가져오라는 것이기 때문이다.
//        // arr+0, arr+1, arr+2
//    }
//    for (int i=0; i<3; i++)
//    {
//        printf("포인터 ptr[%d] 의 값: %d\n", i, ptr[i]);
//    }
//    // *(arr+i) == arr[i] 똑같은 표현
//    // arr == arr배열의 첫번째 값의 주소와 동일 == &arr[0]
//    printf("arr 자체의 값: %d\n", arr);
//    printf("arr[0]의 주소: %d\n", &arr[0]);
//
//    printf("arr 자체의 실제 값: %d\n", *arr); // *(arr+0)
//    printf("arr[0]의 실제 값: %d\n", *&arr[0]);
//
//    // *& 는 아무것도 없는 것과 같다. &는 주소이고, *는 그 주소의 값이기 때문에
//    // 붙어있으면 서로 상쇄가 된다.
    
    
//    // swap
//    int a = 10;
//    int b = 20;
//    // a와 b의 값을 바꾼다.
//    printf("swap함수 전>> a: %d, b: %d\n", a, b);
//
//    swap(a,b);
//    printf("swap함수 후>> a: %d, b: %d\n", a, b);
//
//    printf("a의 주소: %d\n", &a);
//    printf("b의 주소: %d\n", &b);
//    // 함수 정의 안에서는 잘 작동하는데 함수 밖에 나오면 다시 원래 a,b값으로 돌아감.
//    // 값에 의한 복사(call by value) >> 값만 복사한다는 의미.
//    // 즉 우리가 생각하는 값을 바꾸는 작업이 일어나기 위해서는 주소 자체를 바꾸어 주어야 한다.
//    // 10과 20이라는 값만 던져준 것이고, a와 b를 던져준 것은 아니다.
//    // 메인함수에서 a,b의 주소와 swap함수 안에서의 a,b의 주소를 보면 다르다는 것에서
//    // 둘은 서로 다르다는 것을 알 수 있다.
    
    
//    // 그럼 주소값을 넘기면? 메모리 공간에 있는 주소값 자체를 넘기면?
//    printf("(주소값 전달)swap함수 전>> a: %d, b: %d\n", a, b);
//
//    swap_addr(&a,&b);
//    printf("(주소값 전달)swap함수 후>> a: %d, b: %d\n", a, b);
//    // 값이 바뀐다. 이걸 보면 swap을 해주려면 그냥 값만 던져서는 안되고,
//    // 주소 값을 바꿔야 한다는 것을 알 수 있다.
//    // 그리고 그 주소 값을 바꾸기 위해서는 포인터를 이용해야 한다!
    
    // 포인터로 배열 값 변경하기
    int arr2[3] = {10,20,30};
    // 앞에서 배열일 때는 arr2 자체가 배열이 시작되는 주소라고 배웠음.
    changearray(arr2);  // == changearray(&arr2[0]);
    for (int i = 0; i<3; i++)
    {
        printf("%d\n", arr2[i]);
    }
    
    // scanf에서 &num과 같이 &를 사용하는 이유도 이와 같다.
    // 해당 주소에 값을 입력하는 것임.
    
    return 0;
}



// 정의
void swap(int a, int b)
{
    int temp = a;
    a = b;
    b = temp;
//    printf("swap함수 내>> : %d\n", &b);
}

void swap_addr(int *a,int *b)
// 주소는 어떻게? 포인트 변수를 이용해서 받는다.
{
    int temp = *a;
    *a = *b;
    *b = temp;
    printf("(주소값 전달)swap함수 내>> a: %d, b: %d\n", *a, *b);
}

void changearray(int *ptr)
{
    ptr[2] = 50;
}

