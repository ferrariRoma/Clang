//
//  calc.c
//  struct-class
//
//  Created by 안동규 on 2022/03/14.
//

/*
 <필요함수>
 1. 중위 계산법을 받으면 후위 계산법으로 계산
 2. 사칙연산에 따른 우선순위 선정
 3. 변환된 계산법을 읽으면서 숫자는 스택에 넣고,
    사칙연산이 나오면 스택에서 top노드 2개를 빼서 계산하기
    3.0. 괄호는 그것 먼저 계산해야 됨.
    3.1. 가득찼는데 넣으면 오버플로우
    3.2. 텅 비었는데 빼면 언더플로우
 **/

/* <1차 목표> 후위표기법으로 변환하기! 각 항은 띄워주자
항과 항 사이에는 띄워주기
연산자 다음에 있는 계산할 항을 먼저 넣어주고
다시 연산자 위치로 돌아가서 연산자를 dst에 넣어주기
연산자가 아니면 dst에 PUSH! */

/* <2차 목표> *와 /에 우선순위를 주어야 한다!
 숫자는 바로바로 빼고,
 src에서 연산을 우선적으로 해야 하는 /과*는 먼저 계산될 수 있도록!
    1. 연산자가 *나 /이면 일단 연산자스택에 넣어준다.
    2. 연산자가 +나 -이면, 스택에 넣지 않고 스택 안에 있는 다른 연산자들이 있는지 확인한다.
        2.1.1. 있으면 연산자 스택 안에 다른 연산자들을 꺼내준다.
        2.1.2. 꺼내다가 +나 -를 만날 때까지 꺼내줌.
        2.1.3. 다 꺼냈으면 현재 연산자를 연산자 목록에 다시 추가한다.
    3. 그렇게 마지막이 될 때까지 해준다.
    4. 그렇게 마지막이 됐을 때 나머지 +- 연산자들을 역순으로 출력해준다.
 */

// <3차 목표> 괄호 기능은 넣기 "(1+2)/3-2"

#include <stdio.h>

int main_calc(void)
{
    char *src = "A+B*C/D-E";
    char op_stack[16], op_count = 0;
    
    // NULL문자가 나올 때까지 반복
    while(*src){
        // 문자들은 바로바로 출력
        if(*src >= 'A' && *src <= 'Z') printf("%c", *src);
        else {
            // 연산자가 *나 /이면 연산자스택에 넣어준다.
            if(*src == '*' || *src == '/') op_stack[op_count++] = *src;
            else {
                // 연산자가 +나 -이면, 연산자 스택 안에 다른 연산자들을 꺼내준다.
                // 꺼내다가 +나 -를 만날 때까지 꺼내줌
                while(op_count > 0) {
                    if(op_stack[op_count-1] == '+' || op_stack[op_count-1] == '-') break;
                    else printf("%c", op_stack[--op_count]);
                }
                // 현재 연산자를 연산자 목록에 추가한다.
                op_stack[op_count++] = *src;
            }
        }
        src++;
    }
    // +와 -는 마지막에 역순으로 출력해주면 된다.
    while(op_count) printf("%c", op_stack[--op_count]);
    printf("\n");
    return 0;
}
